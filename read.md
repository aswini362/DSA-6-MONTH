
### **DSA Roadmap: 6-8 Months (5-6 Hours/Day, Java Developer)**



**Assumptions**:
- **Work Hours**: 9 AM to 6 PM (with ~1-hour commute each way, leaving evenings/weekends for study).
- **Study Time**: 5-6 hours/day, likely mornings - 5:45 AM - 8:00 AM evening 6:45 PM - 10:45 PM or split with mornings/weekends.
- **Goal**: Achieve DSA proficiency for interviews or competitive programming.
- **Prior Knowledge**: Strong Java fundamentals (OOP, Collections, Streams), some project experience (e.g., email management systems).
- **Total Duration**: 26 weeks (~6 months) for core mastery, extend to 34 weeks (~8 months) for advanced topics.

Below is a detailed **month-by-month plan**, with daily schedules, topics, practice problems, and milestones. Each phase includes Java-specific tips and aligns with your 5-hour daily commitment.
---
### **Month 1: Foundations and Basic Data Structures (4 Weeks, 140 Hours)**
**Goal**: Refresh Java skills, solidify DSA basics, and master core data structures.
- **Week 1: Java Revision and Complexity Analysis (35 Hours)**
    - **Topics**:
        - Advanced Java: `ArrayList`, `LinkedList`, `HashMap`, `HashSet`, `PriorityQueue`, Streams, Generics.
        - Time/Space Complexity: Big-O notation (O(1), O(n), O(n²), O(log n)).
    - **Daily Plan** (Mornings - 5:45 AM - 8:00 AM Evening 6:45 PM - 10:45 PM):
        - 1 hr: Review Java Collections/Streams (e.g., GeeksforGeeks Java section).
        - 1 hr: Study complexity analysis (Big-O, trade-offs).
        - 2 hrs: Solve 4-6 “Easy” LeetCode problems (e.g., “Two Sum” #1, “Reverse String” #344).
        - 1 hr: Optimize a small Java program (e.g., array rotation, string manipulation).
    - **Practice**: Solve 30-40 easy problems (arrays, strings).
    - **Milestone**: Understand complexity, solve 30-40 problems, optimize 2-3 small programs.
- **Weeks 2-4: Arrays, Strings, Linked Lists (105 Hours)**
    - **Topics**:
        - **Arrays**: Linear/binary search, sorting (bubble, selection, insertion), two-pointer.
        - **Strings**: Pattern matching, substring, StringBuilder for efficiency.
        - **Linked Lists**: Singly/doubly linked lists, reverse, cycle detection.
        - **Java-Specific**: Use `ArrayList` for arrays, `StringBuilder` for strings, `LinkedList` for nodes.
    - **Daily Plan**:
        - 1 hr: Study theory (e.g., GeeksforGeeks: Arrays, Linked Lists).
        - 1.5 hrs: Implement data structure in Java (e.g., custom Linked List).
        - 2.5 hrs: Solve 4-6 problems (e.g., “Reverse Linked List” #206, “Contains Duplicate” #217).
    - **Practice**: Solve 50-60 problems (15-20 per data structure).
    - **Resources**:
        - LeetCode: “Array”, “String”, “Linked List” tags.
        - GeeksforGeeks: Data Structures section.
        - Book: “Data Structures and Algorithms in Java” by Robert Lafore.
    - **Milestone**: Implement arrays, strings, and linked lists from scratch, solve 50-60 problems.
### **Month 2: Stacks, Queues, and Basic Algorithms (4 Weeks, 140 Hours)**
**Goal**: Master stacks, queues, and core algorithms.
- **Weeks 1-2: Stacks and Queues (70 Hours)**
    - **Topics**:
        - **Stacks**: Push/pop, parenthesis matching, next greater element.
        - **Queues**: Array-based, circular queue, deque, `PriorityQueue`.
        - **Java-Specific**: Use `Stack`, `LinkedList` (as Queue), `PriorityQueue`.
    - **Daily Plan**:
        - 1 hr: Study theory (e.g., GeeksforGeeks: Stack, Queue).
        - 1.5 hrs: Implement data structure (e.g., Stack using arrays).
        - 2.5 hrs: Solve 4-6 problems (e.g., “Valid Parentheses” #20, “Implement Queue using Stacks” #232).
    - **Practice**: Solve 30-40 problems (15-20 per data structure).
- **Weeks 3-4: Sorting, Searching, Recursion (70 Hours)**
    - **Topics**:
        - **Sorting**: Bubble, Selection, Insertion, Merge, Quick Sort.
        - **Searching**: Linear, Binary Search.
        - **Recursion**: Factorial, Fibonacci, backtracking basics.
        - **Java-Specific**: Use `Arrays.sort()`, `Collections.sort()` for efficiency.
    - **Daily Plan**:
        - 1 hr: Study algorithm theory (e.g., Coursera’s “Algorithms, Part I”).
        - 1.5 hrs: Implement algorithm (e.g., Merge Sort).
        - 2 hrs: Solve 4-6 problems (e.g., “Binary Search” #704, “Sort an Array” #912).
        - 0.5 hr: Analyze complexity.
    - **Practice**: Solve 40-50 problems.
    - **Resources**:
        - LeetCode: “Stack”, “Queue”, “Sort”, “Binary Search” tags.
        - NeetCode YouTube for problem walkthroughs.
    - **Milestone**: Implement stacks, queues, and sorting algorithms, solve 70-90 problems.
### **Month 3: Intermediate Data Structures - Trees and Heaps (4 Weeks, 140 Hours)**
**Goal**: Master trees and heaps for complex problem-solving.
- **Weeks 1-2: Trees (70 Hours)**
    - **Topics**:
        - Binary Tree, Binary Search Tree (BST).
        - Traversals: Inorder, Preorder, Postorder.
        - **Java-Specific**: Use recursive methods, `TreeMap`/`TreeSet` for BST-like behavior.
    - **Daily Plan**:
        - 1 hr: Study tree theory (e.g., GeeksforGeeks: Trees).
        - 1.5 hrs: Implement tree operations (e.g., BST insert/delete).
        - 2.5 hrs: Solve 5-7 problems (e.g., “Invert Binary Tree” #226, “Maximum Depth of Binary Tree” #104).
    - **Practice**: Solve 30-40 problems.
- **Weeks 3-4: Heaps (70 Hours)**
    - **Topics**:
        - Min-Heap, Max-Heap, heap sort.
        - Applications: Top K elements, median in stream.
        - **Java-Specific**: Use `PriorityQueue` for heap operations.
    - **Daily Plan**:
        - 1 hr: Study heap theory.
        - 1.5 hrs: Implement heap (e.g., Min-Heap from scratch).
        - 2.5 hrs: Solve 5-7 problems (e.g., “Kth Largest Element in an Array” #215).
    - **Practice**: Solve 30-40 problems.
    - **Resources**:
        - LeetCode: “Tree”, “Heap” tags.
        - YouTube: Abdul Bari’s tree/heap videos.
    - **Milestone**: Implement BST and heap, solve 60-80 problems.

---

### **Month 4: Intermediate Data Structures - Graphs and Hashing (4 Weeks, 140 Hours)**
**Goal**: Master graphs and advanced hashing.
- **Weeks 1-2: Graphs (70 Hours)**
    - **Topics**:
        - Representation: Adjacency list/matrix.
        - Algorithms: BFS, DFS.
        - **Java-Specific**: Use `HashMap` for adjacency lists.
    - **Daily Plan**:
        - 1 hr: Study graph theory.
        - 1.5 hrs: Implement BFS/DFS in Java.
        - 2.5 hrs: Solve 5-7 problems (e.g., “Number of Islands” #200).
    - **Practice**: Solve 30-40 problems.
- **Weeks 3-4: Hashing (70 Hours)**
    - **Topics**:
        - HashMap, HashSet, collision handling.
        - Applications: Two-sum, frequency counting.
        - **Java-Specific**: Optimize with `HashMap`/`HashSet`.
    - **Daily Plan**:
        - 1 hr: Study hashing concepts.
        - 1.5 hrs: Implement hash-based solutions.
        - 2.5 hrs: Solve 5-7 problems (e.g., “Group Anagrams” #49).
    - **Practice**: Solve 30-40 problems.
    - **Resources**:
        - LeetCode: “Graph”, “Hash Table” tags.
        - GeeksforGeeks: Graph, Hashing sections.
    - **Milestone**: Implement BFS/DFS and hash-based solutions, solve 60-80 problems.

---

### **Month 5: Intermediate Algorithms (5 Weeks, 175 Hours)**
**Goal**: Master algorithmic techniques for complex problems.
- **Weeks 1-2: Greedy and Divide & Conquer (70 Hours)**
    - **Topics**:
        - **Greedy**: Activity selection, minimum spanning tree.
        - **Divide & Conquer**: Merge Sort, Quick Sort applications.
    - **Daily Plan**:
        - 1 hr: Study technique.
        - 1.5 hrs: Implement sample problems.
        - 2.5 hrs: Solve 5-7 problems (e.g., “Jump Game” #55).
    - **Practice**: Solve 30-40 problems.
- **Weeks 3-5: Dynamic Programming (DP) and Sliding Window (105 Hours)**
    - **Topics**:
        - **DP**: Knapsack, longest common subsequence, coin change.
        - **Sliding Window**: Fixed/variable window problems.
        - **Java-Specific**: Use `HashMap` for DP memoization, `StringBuilder` for strings.
    - **Daily Plan**:
        - 1 hr: Study technique.
        - 1.5 hrs: Implement problems.
        - 2.5 hrs: Solve 5-7 problems (e.g., “Climbing Stairs” #70, “Longest Substring Without Repeating Characters” #3).
    - **Practice**: Solve 50-60 problems.
    - **Resources**:
        - LeetCode: “Dynamic Programming”, “Greedy”, “Sliding Window” tags.
        - NeetCode’s DP and Sliding Window playlists.
    - **Milestone**: Solve 80-100 problems, optimize for time/space.

---

### **Month 6: Mock Interviews and Consolidation (5 Weeks, 175 Hours)**
**Goal**: Prepare for interviews with timed practice and review.
- **Daily Plan** (5 hours):
    - 2 hrs: Solve 4-6 LeetCode problems (30% Easy, 50% Medium, 20% Hard).
    - 1.5 hrs: Review solutions, optimize code, or revisit weak areas (e.g., DP, graphs).
    - 1.5 hrs: Mock interviews (Pramp, Interviewing.io) or explain solutions aloud.
- **Practice**:
    - Solve 100-120 problems, focusing on company-specific questions (e.g., Amazon, Google tags).
    - Revisit your email management code (from past discussions) to apply DSA (e.g., HashSet for deduplication).
- **Resources**:
    - LeetCode Premium (optional) for company-tagged problems.
    - HackerRank: Interview Preparation Kit.
    - NeetCode’s 150 curated problem list.
- **Milestone**: Solve 100-120 problems, complete 8-10 mock interviews, confidently explain solutions.

---

### **Months 7-8: Advanced Topics (Optional, 8 Weeks, 280 Hours)**
**Goal**: Master advanced DSA for top-tier companies or competitive programming.
- **Weeks 1-4: Advanced Graphs and Tries (140 Hours)**
    - **Topics**:
        - **Graphs**: Dijkstra’s, Kruskal’s, Prim’s, topological sort.
        - **Tries**: Autocomplete, spell checker.
        - **Java-Specific**: Use `PriorityQueue` for Dijkstra’s, `HashMap` for Tries.
    - **Daily Plan**:
        - 1 hr: Study theory.
        - 1.5 hrs: Implement algorithms.
        - 2.5 hrs: Solve 5-7 problems (e.g., “Word Ladder” #127).
    - **Practice**: Solve 60-80 problems.
- **Weeks 5-8: Segment Trees, DSU, Bit Manipulation (140 Hours)**
    - **Topics**:
        - **Segment Trees**, **Fenwick Trees**: Range queries.
        - **Disjoint Set Union (DSU)**: Union-find for graph problems.
        - **Bit Manipulation**: XOR tricks, bit masking.
    - **Daily Plan**:
        - 1 hr: Study theory.
        - 1.5 hrs: Implement algorithms.
        - 2.5 hrs: Solve 5-7 problems (e.g., “Number of Connected Components” #323).
    - **Practice**: Solve 60-80 problems, participate in 3-5 Codeforces contests.
    - **Resources**:
        - GeeksforGeeks: Advanced Data Structures.
        - Codeforces/AtCoder: Competitive programming.
        - YouTube: Tushar Roy’s advanced DSA videos.
    - **Milestone**: Solve 120-160 problems, compete in 3-5 contests.

---

### **Total Timeline**
- **Core Plan (Months 1-6)**: 26 weeks (~6 months, 910 hours).
- **Extended Plan (Months 1-8)**: 34 weeks (~8 months, 1190 hours).
- **Weekly Commitment**: 35 hours (5 hours/day × 7 days).

### **Daily Schedule (Evening Example)**
- **5:45 AM - 6:40 AM**: Study theory (videos, GeeksforGeeks).
- **6:40 PM - 8:00 AM**: Implement data structure/algorithm.
- **6:45 PM - 10:15 PM**: Solve 4-6 problems.
- **10:15 PM - 10:45 PM**: Analyze solutions or explain aloud.
- **Weekends**: 7-8 hours/day (e.g., 9 AM - 1 PM, 2 PM - 5 PM) for mock interviews or contests.

### **Tips for Success**
- **Leverage Work Experience**: Apply DSA to your projects (e.g., optimize email processing with HashMap or PriorityQueue).
- **Efficiency**: Use Java’s Collections (e.g., `PriorityQueue`, `TreeMap`) to reduce boilerplate.
- **Track Progress**: Log problems solved/topics in a spreadsheet.
- **Mock Interviews**: Practice explaining solutions clearly, as in a job interview.
- **Health**: Take 5-10 minute breaks hourly to avoid burnout.
- **Community**: Join r/leetcode, LeetCode Discuss, or DSA Discord for support.

### **Platforms**
- **LeetCode**: Aim for 400-500 problems (100 Easy, 250 Medium, 50-100 Hard).
- **GeeksforGeeks**: For theory and Java implementations.
- **HackerRank**: For Java-specific DSA.
- **Codeforces**: For competitive programming (Months 7-8).
- **NeetCode**: For curated problem lists and videos.

### **Progress Milestones**
- **Month 2**: Master basic data structures, 100-120 problems solved.
- **Month 4**: Proficient in trees, heaps, and core algorithms, 250-300 problems.
- **Month 6**: Interview-ready, 400-500 problems, 8-10 mock interviews.
- **Month 8 (if extended)**: Advanced DSA mastery, competitive programming skills.

DSA Problem List for 6-8 Month Roadmap
Month 1: Foundations and Basic Data Structures
Week 1: Java Revision and Complexity Analysis

Based on your request to target **mid-sized startup companies** in India for Java developer roles with a **target package of 20 LPA** (approximately $24,000 USD annually, based on current exchange rates), and to integrate the previously provided **problem list for mid-sized startups** with the **general DSA problem list**, I’ve created a consolidated and optimized **LeetCode problem list** tailored for your goal. As a Java developer with **3 years of experience**, a **9 AM to 6 PM** work schedule, and a **5-hour daily study schedule** (5:45 AM - 8:00 AM for 2h15m, 6:45 PM - 9:30 PM for 2h45m), this list refines the preparation plan to align with the expectations of mid-sized startups like **Zoho, Freshworks, Paytm, Swiggy, or Razorpay**, which often offer 15-25 LPA for developers with strong DSA and Java skills.

### **Context and Assumptions**
- **Target Companies**: Mid-sized startups in India (50-500 employees) prioritize practical DSA skills (arrays, strings, linked lists, trees, heaps, graphs, hashing, sorting, searching, greedy, DP, sliding window) for backend roles. They focus on medium-difficulty problems relevant to scalable systems (e.g., REST APIs, microservices, email processing optimization).
- **Target Package (20 LPA)**: Achieving 20 LPA is realistic with 3 years of experience and strong DSA proficiency, especially at startups where CTC includes base salary, bonuses, and stock options. Companies like Freshworks or Paytm often offer 15-25 LPA for SDE-2 or equivalent roles.
- **Study Plan**: 5 hours/day (2h15m morning, 2h45m evening), 35 hours/week, over **6 months (26 weeks, 910 hours)** for core mastery. Advanced topics are excluded to focus on startup-relevant problems, ensuring efficiency.
- **Prior Knowledge**: Strong Java fundamentals (OOP, Collections, Streams), experience with projects like email management systems (e.g., using HashSet for deduplication).
- **Problem Selection**: The list combines the **mid-sized startup problem list** (300 problems) with the **general DSA problem list** (focusing on core and intermediate topics), prioritizing problems tagged for startups or similar companies (e.g., Amazon, Google) on LeetCode. The consolidated list includes **300 problems** (100 Easy, 150 Medium, 50 Hard) to cover all necessary topics while avoiding overlap and advanced topics like segment trees or DSU, which are less common in startup interviews.
- **Daily Schedule**: Aligned with your specified 5:45 AM - 8:00 AM and 6:45 PM - 9:30 PM, with 4-6 problems/day, mock interviews, and Java-specific optimizations.

### **Consolidated LeetCode Problem List for 20 LPA Mid-Sized Startup Roles**

Below is a **300-problem list** (100 Easy, 150 Medium, 50 Hard) curated for mid-sized startup interviews, merging the provided lists and tailored for your 20 LPA goal. Problems are grouped by topic and month, with a focus on practical applications for backend development. Each month targets **50 problems** (4-6/day), with some problems revisited for reinforcement.

#### **Month 1: Foundations and Basic Data Structures (50 Problems)**
**Goal**: Master arrays, strings, and linked lists, foundational for startup interviews.
- **Week 1: Java Revision and Complexity Analysis (10 Problems, Easy)**
    - LeetCode #1: Two Sum (Easy, Array, HashMap)
    - LeetCode #217: Contains Duplicate (Easy, Array, HashSet)
    - LeetCode #242: Valid Anagram (Easy, String, HashMap)
    - LeetCode #136: Single Number (Easy, Array, Bit Manipulation)
    - LeetCode #283: Move Zeroes (Easy, Array, Two-Pointer)
    - LeetCode #350: Intersection of Two Arrays II (Easy, Array, HashMap)
    - LeetCode #344: Reverse String (Easy, String)
    - LeetCode #412: Fizz Buzz (Easy, Array)
    - LeetCode #26: Remove Duplicates from Sorted Array (Easy, Array, Two-Pointer)
    - LeetCode #66: Plus One (Easy, Array)
- **Weeks 2-4: Arrays, Strings, Linked Lists (40 Problems)**
    - **Arrays (15 Problems)**:
        - LeetCode #121: Best Time to Buy and Sell Stock (Easy, Array)
        - LeetCode #88: Merge Sorted Array (Easy, Array, Two-Pointer)
        - LeetCode #189: Rotate Array (Medium, Array)
        - LeetCode #238: Product of Array Except Self (Medium, Array)
        - LeetCode #15: 3Sum (Medium, Array, Two-Pointer)
        - LeetCode #75: Sort Colors (Medium, Array, Sorting)
        - LeetCode #48: Rotate Image (Medium, Array, Matrix)
        - LeetCode #54: Spiral Matrix (Medium, Array, Matrix)
        - LeetCode #73: Set Matrix Zeroes (Medium, Array, Matrix)
        - LeetCode #268: Missing Number (Easy, Array)
        - LeetCode #448: Find All Numbers Disappeared in an Array (Easy, Array)
        - LeetCode #118: Pascal’s Triangle (Easy, Array)
        - LeetCode #119: Pascal’s Triangle II (Easy, Array)
        - LeetCode #169: Majority Element (Easy, Array)
        - LeetCode #498: Diagonal Traverse (Medium, Array, Matrix)
    - **Strings (15 Problems)**:
        - LeetCode #125: Valid Palindrome (Easy, String)
        - LeetCode #392: Is Subsequence (Easy, String, Two-Pointer)
        - LeetCode #28: Find the Index of the First Occurrence in a String (Easy, String)
        - LeetCode #680: Valid Palindrome II (Easy, String)
        - LeetCode #205: Isomorphic Strings (Easy, String, HashMap)
        - LeetCode #49: Group Anagrams (Medium, String, HashMap)
        - LeetCode #3: Longest Substring Without Repeating Characters (Medium, String, Sliding Window)
        - LeetCode #424: Longest Repeating Character Replacement (Medium, String, Sliding Window)
        - LeetCode #5: Longest Palindromic Substring (Medium, String)
        - LeetCode #647: Palindromic Substrings (Medium, String)
        - LeetCode #438: Find All Anagrams in a String (Medium, String, Sliding Window)
        - LeetCode #567: Permutation in String (Medium, String, Sliding Window)
        - LeetCode #14: Longest Common Prefix (Easy, String)
        - LeetCode #58: Length of Last Word (Easy, String)
        - LeetCode #76: Minimum Window Substring (Hard, String, Sliding Window)
    - **Linked Lists (10 Problems)**:
        - LeetCode #206: Reverse Linked List (Easy, Linked List)
        - LeetCode #21: Merge Two Sorted Lists (Easy, Linked List)
        - LeetCode #141: Linked List Cycle (Easy, Linked List, Two-Pointer)
        - LeetCode #234: Palindrome Linked List (Easy, Linked List)
        - LeetCode #83: Remove Duplicates from Sorted List (Easy, Linked List)
        - LeetCode #19: Remove Nth Node From End of List (Medium, Linked List)
        - LeetCode #445: Add Two Numbers II (Medium, Linked List)
        - LeetCode #86: Partition List (Medium, Linked List)
        - LeetCode #61: Rotate List (Medium, Linked List)
        - LeetCode #142: Linked List Cycle II (Medium, Linked List)

#### **Month 2: Stacks, Queues, and Basic Algorithms (50 Problems)**
**Goal**: Master stacks, queues, and core algorithms (sorting, searching) for startup problems.
- **Weeks 1-2: Stacks and Queues (20 Problems)**
    - **Stacks (10 Problems)**:
        - LeetCode #20: Valid Parentheses (Easy, Stack)
        - LeetCode #155: Min Stack (Medium, Stack)
        - LeetCode #225: Implement Stack using Queues (Easy, Stack)
        - LeetCode #682: Baseball Game (Easy, Stack)
        - LeetCode #739: Daily Temperatures (Medium, Stack)
        - LeetCode #496: Next Greater Element I (Easy, Stack)
        - LeetCode #503: Next Greater Element II (Medium, Stack)
        - LeetCode #394: Decode String (Medium, Stack)
        - LeetCode #735: Asteroid Collision (Medium, Stack)
        - LeetCode #901: Online Stock Span (Medium, Stack)
    - **Queues (10 Problems)**:
        - LeetCode #232: Implement Queue using Stacks (Easy, Queue)
        - LeetCode #346: Moving Average from Data Stream (Easy, Queue)
        - LeetCode #933: Number of Recent Calls (Easy, Queue)
        - LeetCode #622: Design Circular Queue (Medium, Queue)
        - LeetCode #641: Design Circular Deque (Medium, Queue)
        - LeetCode #239: Sliding Window Maximum (Hard, Queue, Deque)
        - LeetCode #2073: Time Needed to Buy Tickets (Easy, Queue)
        - LeetCode #1700: Number of Students Unable to Eat Lunch (Easy, Queue)
        - LeetCode #862: Shortest Subarray with Sum at Least K (Hard, Queue)
        - LeetCode #225: Implement Stack using Queues (Easy, Queue, revisit)
- **Weeks 3-4: Sorting, Searching, Recursion (30 Problems)**
    - **Sorting (10 Problems)**:
        - LeetCode #912: Sort an Array (Medium, Sorting)
        - LeetCode #215: Kth Largest Element in an Array (Medium, Quick Sort/Heap)
        - LeetCode #56: Merge Intervals (Medium, Sorting)
        - LeetCode #75: Sort Colors (Medium, Sorting)
        - LeetCode #148: Sort List (Medium, Linked List, Merge Sort)
        - LeetCode #179: Largest Number (Medium, Sorting)
        - LeetCode #252: Meeting Rooms (Easy, Sorting)
        - LeetCode #253: Meeting Rooms II (Medium, Sorting, Heap)
        - LeetCode #88: Merge Sorted Array (Easy, Sorting, revisit)
        - LeetCode #164: Maximum Gap (Hard, Sorting)
    - **Searching (10 Problems)**:
        - LeetCode #704: Binary Search (Easy, Binary Search)
        - LeetCode #33: Search in Rotated Sorted Array (Medium, Binary Search)
        - LeetCode #74: Search a 2D Matrix (Medium, Binary Search)
        - LeetCode #81: Search in Rotated Sorted Array II (Medium, Binary Search)
        - LeetCode #153: Find Minimum in Rotated Sorted Array (Medium, Binary Search)
        - LeetCode #278: First Bad Version (Easy, Binary Search)
        - LeetCode #374: Guess Number Higher or Lower (Easy, Binary Search)
        - LeetCode #875: Koko Eating Bananas (Medium, Binary Search)
        - LeetCode #1011: Capacity To Ship Packages Within D Days (Medium, Binary Search)
        - LeetCode #4: Median of Two Sorted Arrays (Hard, Binary Search)
    - **Recursion (10 Problems)**:
        - LeetCode #509: Fibonacci Number (Easy, Recursion)
        - LeetCode #118: Pascal’s Triangle (Easy, Recursion)
        - LeetCode #1137: N-th Tribonacci Number (Easy, Recursion)
        - LeetCode #206: Reverse Linked List (Easy, Recursion, revisit)
        - LeetCode #21: Merge Two Sorted Lists (Easy, Recursion, revisit)
        - LeetCode #50: Pow(x, n) (Medium, Recursion)
        - LeetCode #39: Combination Sum (Medium, Recursion, Backtracking)
        - LeetCode #40: Combination Sum II (Medium, Recursion, Backtracking)
        - LeetCode #77: Combinations (Medium, Recursion, Backtracking)
        - LeetCode #46: Permutations (Medium, Recursion, Backtracking)

#### **Month 3: Intermediate Data Structures - Trees and Heaps (50 Problems)**
**Goal**: Master trees and heaps, critical for startup system design problems.
- **Weeks 1-2: Trees (25 Problems)**
    - LeetCode #226: Invert Binary Tree (Easy, Binary Tree)
    - LeetCode #104: Maximum Depth of Binary Tree (Easy, Binary Tree)
    - LeetCode #100: Same Tree (Easy, Binary Tree)
    - LeetCode #108: Convert Sorted Array to Binary Search Tree (Easy, BST)
    - LeetCode #98: Validate Binary Search Tree (Medium, BST)
    - LeetCode #101: Symmetric Tree (Easy, Binary Tree)
    - LeetCode #112: Path Sum (Easy, Binary Tree)
    - LeetCode #110: Balanced Binary Tree (Easy, Binary Tree)
    - LeetCode #111: Minimum Depth of Binary Tree (Easy, Binary Tree)
    - LeetCode #235: Lowest Common Ancestor of a Binary Search Tree (Easy, BST)
    - LeetCode #236: Lowest Common Ancestor of a Binary Tree (Medium, Binary Tree)
    - LeetCode #102: Binary Tree Level Order Traversal (Medium, Binary Tree)
    - LeetCode #103: Binary Tree Zigzag Level Order Traversal (Medium, Binary Tree)
    - LeetCode #199: Binary Tree Right Side View (Medium, Binary Tree)
    - LeetCode #113: Path Sum II (Medium, Binary Tree)
    - LeetCode #129: Sum Root to Leaf Numbers (Medium, Binary Tree)
    - LeetCode #124: Binary Tree Maximum Path Sum (Hard, Binary Tree)
    - LeetCode #105: Construct Binary Tree from Preorder and Inorder Traversal (Medium, Binary Tree)
    - LeetCode #106: Construct Binary Tree from Inorder and Postorder Traversal (Medium, Binary Tree)
    - LeetCode #114: Flatten Binary Tree to Linked List (Medium, Binary Tree)
    - LeetCode #99: Recover Binary Search Tree (Hard, BST)
    - LeetCode #450: Delete Node in a BST (Medium, BST)
    - LeetCode #230: Kth Smallest Element in a BST (Medium, BST)
    - LeetCode #173: Binary Search Tree Iterator (Medium, BST)
    - LeetCode #297: Serialize and Deserialize Binary Tree (Hard, Binary Tree)
- **Weeks 3-4: Heaps (25 Problems)**
    - LeetCode #215: Kth Largest Element in an Array (Medium, Heap)
    - LeetCode #703: Kth Largest Element in a Stream (Easy, Heap)
    - LeetCode #347: Top K Frequent Elements (Medium, Heap, HashMap)
    - LeetCode #295: Find Median from Data Stream (Hard, Heap)
    - LeetCode #378: Kth Smallest Element in a Sorted Matrix (Medium, Heap)
    - LeetCode #692: Top K Frequent Words (Medium, Heap)
    - LeetCode #355: Design Twitter (Medium, Heap)
    - LeetCode #451: Sort Characters By Frequency (Medium, Heap)
    - LeetCode #373: Find K Pairs with Smallest Sums (Medium, Heap)
    - LeetCode #264: Ugly Number II (Medium, Heap)
    - LeetCode #313: Super Ugly Number (Medium, Heap)
    - LeetCode #407: Trapping Rain Water II (Hard, Heap)
    - LeetCode #502: IPO (Hard, Heap)
    - LeetCode #632: Smallest Range Covering Elements from K Lists (Hard, Heap)
    - LeetCode #767: Reorganize String (Medium, Heap)
    - LeetCode #857: Minimum Cost to Hire K Workers (Hard, Heap)
    - LeetCode #871: Minimum Number of Refueling Stops (Hard, Heap)
    - LeetCode #973: K Closest Points to Origin (Medium, Heap)
    - LeetCode #1046: Last Stone Weight (Easy, Heap)
    - LeetCode #1337: The K Weakest Rows in a Matrix (Easy, Heap)
    - LeetCode #1383: Maximum Performance of a Team (Hard, Heap)
    - LeetCode #1642: Furthest Building You Can Reach (Medium, Heap)
    - LeetCode #1834: Single-Threaded CPU (Medium, Heap)
    - LeetCode #218: The Skyline Problem (Hard, Heap)
    - LeetCode #253: Meeting Rooms II (Medium, Heap, revisit)

#### **Month 4: Intermediate Data Structures - Graphs and Hashing (50 Problems)**
**Goal**: Master graphs and hashing for system scalability and data processing.
- **Weeks 1-2: Graphs (25 Problems)**
    - LeetCode #200: Number of Islands (Medium, Graph, DFS/BFS)
    - LeetCode #695: Max Area of Island (Medium, Graph, DFS)
    - LeetCode #994: Rotting Oranges (Medium, Graph, BFS)
    - LeetCode #207: Course Schedule (Medium, Graph, Topological Sort)
    - LeetCode #733: Flood Fill (Easy, Graph, DFS/BFS)
    - LeetCode #210: Course Schedule II (Medium, Graph, Topological Sort)
    - LeetCode #417: Pacific Atlantic Water Flow (Medium, Graph, DFS/BFS)
    - LeetCode #547: Number of Provinces (Medium, Graph, DFS/BFS)
    - LeetCode #743: Network Delay Time (Medium, Graph, Dijkstra’s)
    - LeetCode #787: Cheapest Flights Within K Stops (Medium, Graph, Dijkstra’s/Bellman-Ford)
    - LeetCode #332: Reconstruct Itinerary (Medium, Graph, DFS)
    - LeetCode #127: Word Ladder (Hard, Graph, BFS)
    - LeetCode #126: Word Ladder II (Hard, Graph, BFS)
    - LeetCode #785: Is Graph Bipartite? (Medium, Graph, DFS/BFS)
    - LeetCode #886: Possible Bipartition (Medium, Graph, DFS/BFS)
    - LeetCode #797: All Paths From Source to Target (Medium, Graph, DFS)
    - LeetCode #841: Keys and Rooms (Medium, Graph, DFS/BFS)
    - LeetCode #1971: Find if Path Exists in Graph (Easy, Graph, DFS/BFS)
    - LeetCode #1462: Course Schedule IV (Medium, Graph, DFS)
    - LeetCode #399: Evaluate Division (Medium, Graph, DFS)
    - LeetCode #684: Redundant Connection (Medium, Graph, Union-Find)
    - LeetCode #323: Number of Connected Components in an Undirected Graph (Medium, Graph, DFS)
    - LeetCode #261: Graph Valid Tree (Medium, Graph, DFS/Union-Find)
    - LeetCode #990: Satisfiability of Equality Equations (Medium, Graph, Union-Find)
    - LeetCode #1319: Number of Operations to Make Network Connected (Medium, Graph, Union-Find)
- **Weeks 3-4: Hashing (25 Problems)**
    - LeetCode #49: Group Anagrams (Medium, HashMap)
    - LeetCode #1: Two Sum (Easy, HashMap)
    - LeetCode #560: Subarray Sum Equals K (Medium, HashMap)
    - LeetCode #219: Contains Duplicate II (Easy, HashMap)
    - LeetCode #205: Isomorphic Strings (Easy, HashMap)
    - LeetCode #146: LRU Cache (Medium, HashMap, Linked List)
    - LeetCode #454: 4Sum II (Medium, HashMap)
    - LeetCode #525: Contiguous Array (Medium, HashMap)
    - LeetCode #128: Longest Consecutive Sequence (Medium, HashMap)
    - LeetCode #594: Longest Harmonious Subsequence (Easy, HashMap)
    - LeetCode #599: Minimum Index Sum of Two Lists (Easy, HashMap)
    - LeetCode #706: Design HashMap (Easy, HashMap)
    - LeetCode #705: Design HashSet (Easy, HashMap)
    - LeetCode #974: Subarray Sums Divisible by K (Medium, HashMap)
    - LeetCode #981: Time Based Key-Value Store (Medium, HashMap)
    - LeetCode #159: Longest Substring with At Most Two Distinct Characters (Medium, HashMap)
    - LeetCode #340: Longest Substring with At Most K Distinct Characters (Hard, HashMap)
    - LeetCode #992: Subarrays with K Different Integers (Hard, HashMap)
    - LeetCode #930: Binary Subarrays With Sum (Medium, HashMap)
    - LeetCode #904: Fruit Into Baskets (Medium, HashMap)
    - LeetCode #697: Degree of an Array (Easy, HashMap)
    - LeetCode #811: Subdomain Visit Count (Easy, HashMap)
    - LeetCode #953: Verifying an Alien Dictionary (Easy, HashMap)
    - LeetCode #1152: Analyze User Website Visit Pattern (Medium, HashMap)
    - LeetCode #76: Minimum Window Substring (Hard, HashMap, revisit)

#### **Month 5: Intermediate Algorithms (50 Problems)**
**Goal**: Master greedy, divide & conquer, DP, and sliding window for complex problems.
- **Weeks 1-2: Greedy and Divide & Conquer (20 Problems)**
    - **Greedy (10 Problems)**:
        - LeetCode #55: Jump Game (Medium, Greedy)
        - LeetCode #45: Jump Game II (Medium, Greedy)
        - LeetCode #134: Gas Station (Medium, Greedy)
        - LeetCode #406: Queue Reconstruction by Height (Medium, Greedy)
        - LeetCode #763: Partition Labels (Medium, Greedy)
        - LeetCode #435: Non-overlapping Intervals (Medium, Greedy)
        - LeetCode #452: Minimum Number of Arrows to Burst Balloons (Medium, Greedy)
        - LeetCode #605: Can Place Flowers (Easy, Greedy)
        - LeetCode #665: Non-decreasing Array (Easy, Greedy)
        - LeetCode #860: Lemonade Change (Easy, Greedy)
    - **Divide & Conquer (10 Problems)**:
        - LeetCode #169: Majority Element (Easy, Divide & Conquer)
        - LeetCode #241: Different Ways to Add Parentheses (Medium, Divide & Conquer)
        - LeetCode #215: Kth Largest Element in an Array (Medium, Divide & Conquer, revisit)
        - LeetCode #148: Sort List (Medium, Divide & Conquer, revisit)
        - LeetCode #53: Maximum Subarray (Medium, Divide & Conquer)
        - LeetCode #240: Search a 2D Matrix II (Medium, Divide & Conquer)
        - LeetCode #95: Unique Binary Search Trees II (Medium, Divide & Conquer)
        - LeetCode #108: Convert Sorted Array to Binary Search Tree (Easy, Divide & Conquer, revisit)
        - LeetCode #4: Median of Two Sorted Arrays (Hard, Divide & Conquer, revisit)
        - LeetCode #312: Burst Balloons (Hard, Divide & Conquer)
- **Weeks 3-5: Dynamic Programming and Sliding Window (30 Problems)**
    - **Dynamic Programming (15 Problems)**:
        - LeetCode #70: Climbing Stairs (Easy, DP)
        - LeetCode #198: House Robber (Medium, DP)
        - LeetCode #213: House Robber II (Medium, DP)
        - LeetCode #300: Longest Increasing Subsequence (Medium, DP)
        - LeetCode #1143: Longest Common Subsequence (Medium, DP)
        - LeetCode #322: Coin Change (Medium, DP)
        - LeetCode #377: Combination Sum IV (Medium, DP)
        - LeetCode #416: Partition Equal Subset Sum (Medium, DP)
        - LeetCode #518: Coin Change II (Medium, DP)
        - LeetCode #139: Word Break (Medium, DP)
        - LeetCode #5: Longest Palindromic Substring (Medium, DP, revisit)
        - LeetCode #647: Palindromic Substrings (Medium, DP, revisit)
        - LeetCode #62: Unique Paths (Medium, DP)
        - LeetCode #63: Unique Paths II (Medium, DP)
        - LeetCode #64: Minimum Path Sum (Medium, DP)
    - **Sliding Window (15 Problems)**:
        - LeetCode #3: Longest Substring Without Repeating Characters (Medium, Sliding Window)
        - LeetCode #424: Longest Repeating Character Replacement (Medium, Sliding Window)
        - LeetCode #209: Minimum Size Subarray Sum (Medium, Sliding Window)
        - LeetCode #76: Minimum Window Substring (Hard, Sliding Window)
        - LeetCode #438: Find All Anagrams in a String (Medium, Sliding Window, revisit)
        - LeetCode #567: Permutation in String (Medium, Sliding Window, revisit)
        - LeetCode #904: Fruit Into Baskets (Medium, Sliding Window, revisit)
        - LeetCode #159: Longest Substring with At Most Two Distinct Characters (Medium, Sliding Window)
        - LeetCode #340: Longest Substring with At Most K Distinct Characters (Hard, Sliding Window)
        - LeetCode #992: Subarrays with K Different Integers (Hard, Sliding Window)
        - LeetCode #995: Minimum Number of K Consecutive Bit Flips (Hard, Sliding Window)
        - LeetCode #1004: Max Consecutive Ones III (Medium, Sliding Window)
        - LeetCode #1493: Longest Subarray of 1’s After Deleting One Element (Medium, Sliding Window)
        - LeetCode #239: Sliding Window Maximum (Hard, Sliding Window, revisit)
        - LeetCode #930: Binary Subarrays With Sum (Medium, Sliding Window, revisit)

#### **Month 6: Mock Interviews and Consolidation (50 Problems)**
**Goal**: Prepare for startup interviews with timed practice and company-specific problems.
- **Company-Specific (Focus on Startup-Relevant Problems, 50 Problems)**:
    - LeetCode #146: LRU Cache (Medium, HashMap, Linked List)
    - LeetCode #238: Product of Array Except Self (Medium, Array)
    - LeetCode #15: 3Sum (Medium, Array, Two-Pointer)
    - LeetCode #208: Implement Trie (Medium, Trie)
    - LeetCode #253: Meeting Rooms II (Medium, Heap, Sorting)
    - LeetCode #236: Lowest Common Ancestor of a Binary Tree (Medium, Tree)
    - LeetCode #121: Best Time to Buy and Sell Stock (Easy, Array)
    - LeetCode #42: Trapping Rain Water (Hard, Two-Pointer, Stack)
    - LeetCode #23: Merge K Sorted Lists (Hard, Linked List, Heap)
    - LeetCode #124: Binary Tree Maximum Path Sum (Hard, Tree)
    - LeetCode #49: Group Anagrams (Medium, HashMap, revisit)
    - LeetCode #1: Two Sum (Easy, HashMap, revisit)
    - LeetCode #215: Kth Largest Element in an Array (Medium, Heap, revisit)
    - LeetCode #206: Reverse Linked List (Easy, Linked List, revisit)
    - LeetCode #21: Merge Two Sorted Lists (Easy, Linked List, revisit)
    - LeetCode #200: Number of Islands (Medium, Graph, DFS/BFS, revisit)
    - LeetCode #207: Course Schedule (Medium, Graph, Topological Sort, revisit)
    - LeetCode #56: Merge Intervals (Medium, Sorting, revisit)
    - LeetCode #3: Longest Substring Without Repeating Characters (Medium, Sliding Window, revisit)
    - LeetCode #76: Minimum Window Substring (Hard, Sliding Window, revisit)
    - LeetCode #70: Climbing Stairs (Easy, DP, revisit)
    - LeetCode #198: House Robber (Medium, DP, revisit)
    - LeetCode #300: Longest Increasing Subsequence (Medium, DP, revisit)
    - LeetCode #704: Binary Search (Easy, Binary Search, revisit)
    - LeetCode #33: Search in Rotated Sorted Array (Medium, Binary Search, revisit)
    - LeetCode #20: Valid Parentheses (Easy, Stack, revisit)
    - LeetCode #155: Min Stack (Medium, Stack, revisit)
    - LeetCode #104: Maximum Depth of Binary Tree (Easy, Tree, revisit)
    - LeetCode #98: Validate Binary Search Tree (Medium, BST, revisit)
    - LeetCode #347: Top K Frequent Elements (Medium, Heap, HashMap, revisit)
    - LeetCode #141: Linked List Cycle (Easy, Linked List, revisit)
    - LeetCode #234: Palindrome Linked List (Easy, Linked List, revisit)
    - LeetCode #125: Valid Palindrome (Easy, String, revisit)
    - LeetCode #392: Is Subsequence (Easy, String, revisit)
    - LeetCode #55: Jump Game (Medium, Greedy, revisit)
    - LeetCode #45: Jump Game II (Medium, Greedy, revisit)
    - LeetCode #134: Gas Station (Medium, Greedy, revisit)
    - LeetCode #169: Majority Element (Easy, Divide & Conquer, revisit)
    - LeetCode #53: Maximum Subarray (Medium, Divide & Conquer, revisit)
    - LeetCode #5: Longest Palindromic Substring (Medium, DP, revisit)
    - LeetCode #139: Word Break (Medium, DP, revisit)
    - LeetCode #424: Longest Repeating Character Replacement (Medium, Sliding Window, revisit)
    - LeetCode #209: Minimum Size Subarray Sum (Medium, Sliding Window, revisit)
    - LeetCode #560: Subarray Sum Equals K (Medium, HashMap, revisit)
    - LeetCode #128: Longest Consecutive Sequence (Medium, HashMap, revisit)
    - LeetCode #102: Binary Tree Level Order Traversal (Medium, Tree, revisit)
    - LeetCode #103: Binary Tree Zigzag Level Order Traversal (Medium, Tree, revisit)
    - LeetCode #695: Max Area of Island (Medium, Graph, DFS, revisit)
    - LeetCode #994: Rotting Oranges (Medium, Graph, BFS, revisit)
    - LeetCode #297: Serialize and Deserialize Binary Tree (Hard, Tree, revisit)

---

### **Daily Schedule (5 Hours/Day, Morning + Evening)**
- **Morning (5:45 AM - 8:00 AM, 2h15m)**:
    - **5:45 AM - 6:45 AM**: Study theory (GeeksforGeeks, NeetCode videos) or review weak areas.
    - **6:45 AM - 8:00 AM**: Implement data structure/algorithm or solve 2-3 problems from the list.
- **Evening (6:45 PM - 9:30 PM, 2h45m)**:
    - **6:45 PM - 7:30 PM**: Complete implementation or review theory.
    - **7:30 PM - 9:30 PM**: Solve 3-5 problems or practice mock interviews (Pramp, Interviewing.io).
- **Weekends**: 7-8 hours/day (e.g., 9 AM - 1 PM, 2 PM - 5 PM) for mock interviews, contests, or revisiting hard problems.

---

### **Key Notes for 20 LPA Goal**
- **Total Problems**: 300 (100 Easy, 150 Medium, 50 Hard) over 6 months (~50 problems/month, 4-6/day).
- **Why This List?**:
    - Combines the **mid-sized startup list** (300 problems) with the **general DSA list**, prioritizing problems relevant to startups like Zoho, Freshworks, or Paytm.
    - Excludes advanced topics (segment trees, Fenwick trees, bit manipulation, DSU) to focus on core and intermediate topics (arrays, strings, linked lists, trees, heaps, graphs, hashing, sorting, searching, greedy, DP, sliding window).
    - Includes revisited problems to reinforce key concepts (e.g., Two Sum, Reverse Linked List, Longest Substring Without Repeating Characters).
    - Covers company-specific problems (e.g., LRU Cache, Meeting Rooms II) commonly asked in startup interviews.
- **Java-Specific Tips**:
    - Use `HashMap`/`HashSet` for efficient lookups (e.g., Two Sum, Group Anagrams).
    - Leverage `StringBuilder` for string manipulation (e.g., Longest Palindromic Substring).
    - Use `PriorityQueue` for heap-based problems (e.g., Top K Frequent Elements).
    - Implement linked lists with custom `ListNode` class (e.g., Reverse Linked List).
    - Optimize tree traversals with recursion or iterative approaches (e.g., Binary Tree Level Order Traversal).
- **Startup Interview Focus**:
    - Mid-sized startups emphasize practical problems (e.g., Two Sum, LRU Cache, Meeting Rooms II) relevant to backend systems, REST APIs, and microservices.
    - Expect 2-3 coding rounds (Easy/Medium problems) and 1 system design round (basic, e.g., design an email notification system).
    - Communication and code clarity are critical; practice explaining solutions aloud.
- **Application to Work**: Apply DSA to your email management system (e.g., HashSet for deduplication, PriorityQueue for prioritized email processing, graphs for email thread relationships).
- **Resources**:
    - **LeetCode**: Focus on “Array”, “String”, “Linked List”, “Tree”, “Heap”, “Graph”, “Hash Table”, “Sorting”, “Binary Search”, “Greedy”, “Dynamic Programming”, “Sliding Window” tags.
    - **GeeksforGeeks**: For Java implementations and theory.
    - **HackerRank**: For startup-relevant challenges.
    - **NeetCode**: For curated problem lists and videos.
- **Progress Tracking**: Log problems in a spreadsheet (problem number, title, difficulty, date solved, notes on approach).
- **Mock Interviews**: Complete 8-10 mock interviews (Pramp, Interviewing.io) by Month 6, focusing on startup-like problems.
- **20 LPA Strategy**:
    - With 3 years of experience, aim for **SDE-2 or equivalent roles** at mid-sized startups (e.g., Freshworks, Paytm).
    - Highlight DSA proficiency, Java expertise, and project experience (e.g., email management system) on your resume and LinkedIn.
    - Network with recruiters or employees at target companies via LinkedIn or job platforms like Cutshort or AngelList.
    - Prepare for basic system design (e.g., design a URL shortener or notification system) alongside DSA.

---

### **Progress Milestones**
- **Month 2**: Master basic data structures, 100 problems solved.
- **Month 4**: Proficient in trees, heaps, graphs, hashing, 200 problems solved.
- **Month 6**: Interview-ready, 300 problems solved, 8-10 mock interviews completed, confident in explaining solutions.

# 🛠️ DSA Roadmap (Beginner → Advanced)

A structured roadmap to go from **beginner → advanced** in DSA, with **topic-wise problems**.  
Recommended language: **Java** (but you can adapt to any language).

---

## 1. Basics (Logic Building + Math)

**Focus**: Conditionals, loops, operators, logic formation.  
👉 Start here to warm up.

- [ ] Print patterns (triangle, pyramid, diamond, etc.)
- [ ] Reverse a number
- [ ] Palindrome number
- [ ] Armstrong number
- [ ] GCD & LCM of two numbers
- [ ] Prime check & print primes in range
- [ ] Count digits / sum of digits
- [ ] Power of a number (fast exponentiation)
- [ ] Factorial & nCr
- [ ] Fibonacci series

---

## 2. Arrays (Core Foundation)

**Focus**: Traversal, searching, prefix, two-pointers.

- [ ] Find max/min in array
- [ ] Reverse array
- [ ] Rotate array (left/right by k steps)
- [ ] Check if array is sorted
- [ ] Remove duplicates (sorted + unsorted)
- [ ] Second largest element
- [ ] Move zeroes to end
- [ ] Two Sum (pair with target sum)
- [ ] Leaders in array
- [ ] Majority Element (Moore’s Voting)
- [ ] Kadane’s Algorithm (max subarray sum)
- [ ] Prefix sum problems (range sum queries)

---

## 3. Strings (Character Manipulation)

**Focus**: ASCII, anagrams, hashing with frequency arrays.

- [ ] Reverse a string / words in string
- [ ] Palindrome string
- [ ] Count vowels & consonants
- [ ] Check anagram
- [ ] Valid palindrome with removals
- [ ] Longest common prefix
- [ ] Longest substring without repeating characters
- [ ] Group anagrams
- [ ] String compression
- [ ] Valid parentheses

---

## 4. Searching

**Focus**: Binary search mastery (very important).

- [ ] Linear search
- [ ] Binary search (basic)
- [ ] First and last occurrence of element
- [ ] Count occurrences of element
- [ ] Square root using binary search
- [ ] Search in rotated sorted array
- [ ] Find peak element
- [ ] Allocate books / Painter partition (binary search on answer)
- [ ] Median of two sorted arrays

---

## 5. Sorting

**Focus**: Brute force → efficient sorting.

- [ ] Bubble sort
- [ ] Insertion sort
- [ ] Selection sort
- [ ] Merge sort
- [ ] Quick sort
- [ ] Counting sort / Radix sort
- [ ] Sort colors (Dutch National Flag)
- [ ] Find kth largest element
- [ ] Merge intervals
- [ ] Meeting rooms problem

---

## 6. Recursion & Backtracking

**Focus**: Divide problems into subproblems.

- [ ] Factorial recursion
- [ ] Fibonacci recursion
- [ ] Print all subsequences
- [ ] Subset sum problem
- [ ] Generate all permutations of array/string
- [ ] N-Queens problem
- [ ] Rat in a Maze
- [ ] Sudoku Solver
- [ ] Word Search

---

## 7. Hashing (Maps + Sets)

**Focus**: Frequency-based + optimization with hashing.

- [ ] Two Sum using hashmap
- [ ] Subarray with 0 sum
- [ ] Subarray with given sum
- [ ] Count distinct elements in window
- [ ] Longest consecutive sequence
- [ ] Longest subarray with equal 0s and 1s
- [ ] Group anagrams (using hashmap)

---

## 8. Linked List

**Focus**: Pointers, fast/slow pointers.

- [ ] Reverse a linked list
- [ ] Detect cycle in linked list (Floyd’s algo)
- [ ] Middle of linked list
- [ ] Merge two sorted linked lists
- [ ] Remove Nth node from end
- [ ] Add two numbers (linked list representation)
- [ ] Flatten a linked list
- [ ] Clone a linked list with random pointer

---

## 9. Stack & Queue

**Focus**: LIFO & FIFO problems.

- [ ] Implement stack & queue (array & linked list)
- [ ] Min stack
- [ ] Next greater element
- [ ] Valid parentheses
- [ ] Largest rectangle in histogram
- [ ] Sliding window maximum
- [ ] Circular queue
- [ ] Implement LRU Cache

---

## 10. Trees (Binary Tree + BST)

**Focus**: Traversals, recursion, BST properties.

- [ ] Binary tree traversals (inorder, preorder, postorder, level order)
- [ ] Height of tree
- [ ] Diameter of tree
- [ ] Lowest common ancestor (LCA)
- [ ] Balanced binary tree check
- [ ] Zigzag level order traversal
- [ ] Serialize & deserialize binary tree
- [ ] BST insert & delete
- [ ] Validate BST
- [ ] Kth smallest element in BST

---

## 11. Heap & Priority Queue

**Focus**: Greedy + optimization.

- [ ] Kth largest element
- [ ] Heap sort
- [ ] Merge k sorted lists
- [ ] Find median from data stream
- [ ] Top k frequent elements
- [ ] Sliding window median

---

## 12. Graphs

**Focus**: BFS, DFS, shortest paths.

- [ ] BFS & DFS traversal
- [ ] Detect cycle in graph (BFS & DFS)
- [ ] Number of islands
- [ ] Rotten oranges
- [ ] Shortest path in unweighted graph (BFS)
- [ ] Dijkstra’s algorithm
- [ ] Bellman-Ford algorithm
- [ ] Floyd-Warshall
- [ ] Minimum spanning tree (Prim’s, Kruskal’s)
- [ ] Topological sort (DFS + Kahn’s algo)

---

## 13. Dynamic Programming (DP)

**Focus**: Break problems → overlapping subproblems.

- [ ] Fibonacci (memo + tabulation)
- [ ] Climbing stairs
- [ ] Coin change (min coins / total ways)
- [ ] Longest common subsequence (LCS)
- [ ] Longest increasing subsequence (LIS)
- [ ] Matrix chain multiplication
- [ ] Minimum path sum
- [ ] Edit distance
- [ ] 0/1 Knapsack
- [ ] Partition equal subset sum

---

## 14. Advanced Topics

- [ ] Bit Manipulation (XOR tricks, subset generation, power set)
- [ ] Disjoint Set Union (Union-Find)
- [ ] Tries (Prefix tree)
- [ ] Segment Tree / Fenwick Tree
- [ ] Advanced DP (Digit DP, DP on Trees)

---

## ⚡ Strategy

- ✅ Solve **~40 beginner problems** (math, arrays, strings) to sharpen logic.
- ✅ Move to **binary search, recursion, sorting**.
- ✅ Then master **linked list, stack, queue**.
- ✅ Finally, tackle **trees, graphs, DP, advanced topics**.

---

> 📝 Pro Tip: Track your progress by checking `[ ]` → `[x]` once solved.  
> 💡 Recommended platforms: **LeetCode, GeeksForGeeks, Codeforces (for contests)**.
